<meta charset="utf-8"/>
<co-content>
 <p>
 </p>
 <asset assettype="pdf" extension="pdf" id="j3Gmbz4EEeahSAoAQvTmYw" name="statement-forest">
 </asset>
 <p>
  Данное задание основано на материалах лекций по логическим методам и направлено на знакомство со случайными лесами (Random Forests).
 </p>
 <h2 level="2">
  Вы научитесь:
 </h2>
 <ul bullettype="bullets">
  <li>
   <p>
    работать со случайным лесом — одним из наиболее распространенных семейств алгоритмов
   </p>
  </li>
  <li>
   <p>
    решать с его помощью задачи регрессии
   </p>
  </li>
  <li>
   <p>
    подбирать параметры случайного леса
   </p>
  </li>
 </ul>
 <h2 level="2">
  Введение
 </h2>
 <p>
  Случайный лес — это модель классификации, объединяющая некоторое количество решающих деревьев в одну композицию, за счет чего улучшается их качество работы и обобщающая способность. Деревья строятся независимо друг от друга. Чтобы они отличались друг от друга, обучение проводится не на всей обучающей выборке, а на ее случайном подмножестве. Также, для дальнейшего уменьшения схожести деревьев, оптимальный признак для разбиения выбирается не из всех возможных признаков, а лишь из их случайного подмножества. Прогнозы, выданные деревьями, объединяются в один ответ путем усреднения.
 </p>
 <p>
  Особенность случайного леса заключается в том, что он не переобучается по мере увеличения количества деревьев в композиции. Это достигается за счет того, что деревья не зависят друг от друга, и поэтому добавление нового дерева в композицию не усложняет модель, а лишь понижает уровень шума в прогнозах.
 </p>
 <h2 level="2">
  Реализация в Scikit-Learn
 </h2>
 <p>
  В библиотеке scikit-learn случайные леса реализованы в классах sklearn.ensemble.RandomForestClassifier (для классификации) и sklearn.ensemble.RandomForestRegressor (для регрессии). Обучение модели производится с помощью функции fit, построение прогнозов — с помощью функции predict. Число деревьев задается с помощью поля класса n_estimators.
 </p>
 <p>
  Пример использования:
 </p>
 <pre language="python">import numpy as np
from sklearn.ensemble import RandomForestRegressor
X = np.array([[1, 2], [3, 4], [5, 6]])
y = np.array([-3, 1, 10])
clf = RandomForestRegressor(n_estimators=100)
clf.fit(X, y)
predictions = clf.predict(X)</pre>
 <p>
  Также в этом задании вам понадобится вычислять качество предсказаний на тестовой выборке. Мы будем пользоваться метрикой R2 — по сути, это среднеквадратичная ошибка (MSE), нормированная на отрезок [0, 1] и обращенная так, чтобы ее наилучшим значением была единица. Ее можно вычислить с помощью функции sklearn.metrics.r2_score. Первым аргументов является список правильных ответов на выборке, вторым — список предсказанных ответов. Пример использования:
 </p>
 <pre language="python">from sklearn.metrics import r2_score
print r2_score([10, 11, 12], [9, 11, 12.1])</pre>
 <h2 level="2">
  Инструкция по выполнению
 </h2>
 <p>
  В этом задании вам нужно проследить за изменением качества случайного леса в зависимости от количества деревьев в нем.
 </p>
 <ol bullettype="numbers">
  <li>
   <p>
    Загрузите данные из файла abalone.csv. Это датасет, в котором требуется предсказать возраст ракушки (число колец) по физическим измерениям.
   </p>
  </li>
  <li>
   <p>
    Преобразуйте признак Sex в числовой: значение F должно перейти в -1, I — в 0, M — в 1. Если вы используете Pandas, то подойдет следующий код: data['Sex'] = data['Sex'].map(lambda x: 1 if x == 'M' else (-1 if x == 'F' else 0))
   </p>
  </li>
  <li>
   <p>
    Разделите содержимое файлов на признаки и целевую переменную. В последнем столбце записана целевая переменная, в остальных — признаки.
   </p>
  </li>
  <li>
   <p>
    Обучите случайный лес (sklearn.ensemble.RandomForestRegressor) с различным числом деревьев: от 1 до 50 (не забудьте выставить "random_state=1" в конструкторе). Для каждого из вариантов оцените качество работы полученного леса на кросс-валидации по 5 блокам. Используйте параметры "random_state=1" и "shuffle=True" при создании генератора кросс-валидации sklearn.cross_validation.KFold.  В качестве меры качества воспользуйтесь коэффициентом детерминации (sklearn.metrics.r2_score).
   </p>
  </li>
  <li>
   <p>
    Определите, при каком минимальном количестве деревьев случайный лес показывает качество на кросс-валидации выше 0.52. Это количество и будет ответом на задание.
   </p>
  </li>
  <li>
   <p>
    Обратите внимание на изменение качества по мере роста числа деревьев. Ухудшается ли оно?
   </p>
  </li>
 </ol>
 <p>
 </p>
 <p>
  Ответ на каждое задание — текстовый файл, содержащий ответ в первой строчке. Обратите внимание, что отправляемые файлы не должны содержать перевод строки в конце. Данный нюанс является ограничением платформы Coursera. Мы работаем над тем, чтобы убрать это ограничение.
 </p>
 <p>
 </p>
 <asset assettype="generic" extension="csv" id="y3vFsb3YEeWtBA4YeZyKCw" name="abalone">
 </asset>
 <p>
 </p>
 <p>
 </p>
 <p>
 </p>
 <p>
 </p>
 <p>
 </p>
 <p>
 </p>
 <p>
 </p>
 <p>
 </p>
 <p>
 </p>
</co-content>
<style>
 body {
    padding: 50px 85px 50px 85px;
}

table th, table td {
    border: 1px solid #e0e0e0;
    padding: 5px 20px;
    text-align: left;
}
input {
    margin: 10px;
}
}
th {
    font-weight: bold;
}
td, th {
    display: table-cell;
    vertical-align: inherit;
}
img {
    height: auto;
    max-width: 100%;
}
pre {
    display: block;
    margin: 20px;
    background: #424242;
    color: #fff;
    font-size: 13px;
    white-space: pre-wrap;
    padding: 9.5px;
    margin: 0 0 10px;
    border: 1px solid #ccc;
}
</style>
<script async="" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
</script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$$','$$'], ['$','$'] ],
      displayMath: [ ["\\[","\\]"] ],
      processEscapes: true
    }
  });
</script>
