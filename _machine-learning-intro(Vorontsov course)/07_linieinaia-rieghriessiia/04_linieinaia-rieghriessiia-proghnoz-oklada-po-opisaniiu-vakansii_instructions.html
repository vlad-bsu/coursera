<meta charset="utf-8"/>
<co-content>
 <asset assettype="pdf" extension="pdf" id="l8-lCmyaEeayyA4wl7sUBw" name="statement-linreg">
 </asset>
 <p>
  Данное задание основано на материалах лекций по линейной регрессии и посвящено предсказанию оклада, исходя из описания вакансии.
 </p>
 <h2 level="2">
  Вы научитесь:
 </h2>
 <ul bullettype="bullets">
  <li>
   <p>
    использовать линейную регрессию
   </p>
  </li>
  <li>
   <p>
    применять линейную регрессию к текстовым данным
   </p>
  </li>
 </ul>
 <h2 level="2">
  Введение
 </h2>
 <p>
  Линейные методы хорошо подходят для работы с разреженными данными — к таковым относятся, например, тексты. Это можно объяснить высокой скоростью обучения и небольшим количеством параметров, благодаря чему удается избежать переобучения.
 </p>
 <p>
  Линейная регрессия имеет несколько разновидностей в зависимости от того, какой регуляризатор используется. Мы будем работать с гребневой регрессией, где применяется квадратичный, или L2-регуляризатор.
 </p>
 <h2 level="2">
  Реализация в Scikit-Learn
 </h2>
 <p>
  Для извлечения TF-IDF-признаков из текстов воспользуйтесь классом sklearn.feature_extraction.text.TfidfVectorizer.
 </p>
 <p>
  Для предсказания целевой переменной мы будем использовать гребневую регрессию, которая реализована в классе sklearn.linear_model.Ridge.
 </p>
 <p>
  Обратите внимание, что признаки LocationNormalized и ContractTime являются строковыми, и поэтому с ними нельзя работать напрямую. Такие нечисловые признаки с неупорядоченными значениями называют категориальными или номинальными. Типичный подход к их обработке — кодирование категориального признака с m возможными значениями с помощью m бинарных признаков. Каждый бинарный признак соответствует одному из возможных значений категориального признака и является индикатором того, что на данном объекте он принимает данное значение. Данный подход иногда называют one-hot-кодированием. Воспользуйтесь им, чтобы перекодировать признаки LocationNormalized и ContractTime. Он уже реализован в классе sklearn.feature_extraction.DictVectorizer. Пример использования:
 </p>
 <pre>from sklearn.feature_extraction import DictVectorizer
enc = DictVectorizer()
X_train_categ = enc.fit_transform(data_train[['LocationNormalized', 'ContractTime']].to_dict('records'))
X_test_categ = enc.transform(data_test[['LocationNormalized', 'ContractTime']].to_dict('records'))</pre>
 <p>
  Вам понадобится производить замену пропущенных значений на специальные строковые величины (например, 'nan'). Для этого подходит следующий код:
 </p>
 <pre>data_train['LocationNormalized'].fillna('nan', inplace=True)
data_train['ContractTime'].fillna('nan', inplace=True)
</pre>
 <h2 level="2">
  Инструкция по выполнению
 </h2>
 <ol bullettype="numbers">
  <li>
   <p>
    Загрузите данные об описаниях вакансий и соответствующих годовых зарплатах из файла salary-train.csv (либо его заархивированную версию salary-train.zip).
   </p>
  </li>
  <li>
   <p>
    Проведите предобработку:
   </p>
  </li>
 </ol>
 <ul bullettype="bullets">
  <li>
   <p>
    Приведите тексты к нижнему регистру (text.lower()).
   </p>
  </li>
  <li>
   <p>
    Замените все, кроме букв и цифр, на пробелы — это облегчит дальнейшее разделение текста на слова. Для такой замены в строке text подходит следующий вызов: re.sub('[^a-zA-Z0-9]', ' ', text). Также можно воспользоваться методом replace у DataFrame, чтобы сразу преобразовать все тексты:
   </p>
  </li>
 </ul>
 <pre>train['FullDescription'] = train['FullDescription'].replace('[^a-zA-Z0-9]', ' ', regex = True)</pre>
 <ul bullettype="bullets">
  <li>
   <p>
    Примените TfidfVectorizer для преобразования текстов в векторы признаков. Оставьте только те слова, которые встречаются хотя бы в 5 объектах (параметр min_df у TfidfVectorizer).
   </p>
  </li>
  <li>
   <p>
    Замените пропуски в столбцах LocationNormalized и ContractTime на специальную строку 'nan'. Код для этого был приведен выше.
   </p>
  </li>
  <li>
   <p>
    Примените DictVectorizer для получения one-hot-кодирования признаков LocationNormalized и ContractTime.
   </p>
  </li>
  <li>
   <p>
    Объедините все полученные признаки в одну матрицу "объекты-признаки". Обратите внимание, что матрицы для текстов и категориальных признаков являются разреженными. Для объединения их столбцов нужно воспользоваться функцией scipy.sparse.hstack.
   </p>
  </li>
 </ul>
 <p>
  3.  Обучите гребневую регрессию с параметрами alpha=1 и random_state=241. Целевая переменная записана в столбце SalaryNormalized.
 </p>
 <p>
  4.  Постройте прогнозы для двух примеров из файла salary-test-mini.csv. Значения полученных прогнозов являются ответом на задание. Укажите их через пробел.
 </p>
 <p>
 </p>
 <p>
  Если ответом является нецелое число, то целую и дробную часть необходимо разграничивать точкой, например, 0.42. При необходимости округляйте дробную часть до двух знаков.
 </p>
 <p>
  Ответ на каждое задание — текстовый файл, содержащий ответ в первой строчке. Обратите внимание, что отправляемые файлы не должны содержать перевод строки в конце. Данный нюанс является ограничением платформы Coursera. Мы работаем над тем, чтобы убрать это ограничение.
 </p>
 <asset assettype="generic" extension="csv" id="3YmHrLvEEeWg-hLO0rEOAw" name="salary-train">
 </asset>
 <asset assettype="generic" extension="csv" id="m2fQRMUiEeWFNA5XwZEiOw" name="salary-test-mini">
 </asset>
 <p>
 </p>
 <asset assettype="generic" extension="zip" id="6IEiT-JWEeWIdgqHxZs34w" name="salary-train">
 </asset>
 <p>
 </p>
 <p>
 </p>
 <p>
 </p>
 <p>
 </p>
 <p>
 </p>
</co-content>
<style>
 body {
    padding: 50px 85px 50px 85px;
}

table th, table td {
    border: 1px solid #e0e0e0;
    padding: 5px 20px;
    text-align: left;
}
input {
    margin: 10px;
}
}
th {
    font-weight: bold;
}
td, th {
    display: table-cell;
    vertical-align: inherit;
}
img {
    height: auto;
    max-width: 100%;
}
pre {
    display: block;
    margin: 20px;
    background: #424242;
    color: #fff;
    font-size: 13px;
    white-space: pre-wrap;
    padding: 9.5px;
    margin: 0 0 10px;
    border: 1px solid #ccc;
}
</style>
<script async="" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
</script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$$','$$'], ['$','$'] ],
      displayMath: [ ["\\[","\\]"] ],
      processEscapes: true
    }
  });
</script>
