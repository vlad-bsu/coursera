<meta charset="utf-8"/>
<co-content>
 <asset assettype="pdf" extension="pdf" id="fH9yhm1aEeaI_hJe858l4Q" name="statement-clustering">
 </asset>
 <p>
  Данное задание основано на материалах лекций по методу k-средних (K-Means). Обратите внимание, что задание не является обязательным.
 </p>
 <h2 level="2">
  Вы научитесь:
 </h2>
 <ul bullettype="bullets">
  <li>
   <p>
    использовать алгоритм K-Means
   </p>
  </li>
  <li>
   <p>
    работать с задачами обучения без учителя
   </p>
  </li>
  <li>
   <p>
    работать с изображениям в Python
   </p>
  </li>
 </ul>
 <h2 level="2">
  Введение
 </h2>
 <p>
  Самый распространенный тип задач машинного обучения — это задачи обучения с учителем. В них имеется обучающая выборка, для каждого объекта которой есть ответ, и нужно научиться предсказывать эти ответы для новых объектов. В такой постановке можно строго определить критерии качества.
 </p>
 <p>
  Если же имеются лишь объекты, а ответов для них нет, то все равно можно пытаться найти в данных некую структуру. Задачи, которые ищут закономерности в неразмеченных выборках, называют задачами обучения без учителя. Типичный пример такой задачи — кластеризация, где требуется найти группы похожих объектов.
 </p>
 <p>
  Кластеризация может использоваться для самых разных целей. В этом задании мы попробуем группировать схожие пиксели на изображении. Такой подход позволяет переходить к суперпиксельному представлению изображений, которое является более компактным и лучше подходит для решения ряда задач компьютерного зрения.
 </p>
 <h2 level="2">
  Реализация в sklearn
 </h2>
 <p>
  Алгоритм KMeans реализован в классе sklearn.cluster.KMeans. Так как это один из примеров unsupervised-задачи, для обучения достаточно передать только матрицу объектов.
 </p>
 <p>
  В качестве метрики будем использовать
  <a href="https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio">
   PSNR
  </a>
  — адаптация метрики MSE для задачи нахождениях сходства изображений.
 </p>
 <p>
  Для работы с изображениями мы рекомендуем воспользоваться пакетом
  <a href="http://scikit-image.org">
   scikit-image
  </a>
  . Чтобы загрузить изображение, необходимо выполнить следующую команду:
 </p>
 <pre>from skimage.io import imread
image = imread('parrots_4.jpg')</pre>
 <p>
  После этих действий переменная
  <em>
   image
  </em>
  будет содержать изображение в виде numpy-массива размера n * m * 3, где n и m соответствуют размерам изображения, а 3 соответствует формату представления RGB.
 </p>
 <p>
  Если вы хотите вывести изображение на экран, необходимо, чтобы у вас была установлена библиотека matplotlib. С помощью нее это делается следующим образом:
 </p>
 <pre>import pylab
pylab.imshow(image)
</pre>
 <p>
  Если вы работаете в ipython-notebook'е, то вам необходимо перед выполнением кода выше исполнить в любой ячейке инструкцию:
 </p>
 <pre>%matplotlib inline</pre>
 <p>
  Она позволяет выводить изображения прямо в ipython-notebook.
 </p>
 <h2 level="2">
  Инструкция по выполнению
 </h2>
 <ol bullettype="numbers">
  <li>
   <p>
    Загрузите картинку parrots.jpg. Преобразуйте изображение, приведя все значения в интервал от 0 до 1. Для этого можно воспользоваться функцией
    <em>
     <a href="http://scikit-image.org/docs/dev/api/skimage.html">
      img_as_float
     </a>
    </em>
    из модуля skimage. Обратите внимание на этот шаг, так как при работе с исходным изображением вы получите некорректный результат.
   </p>
  </li>
  <li>
   <p>
    Создайте матрицу объекты-признаки: характеризуйте каждый пиксель тремя координатами - значениями интенсивности в пространстве RGB.
   </p>
  </li>
  <li>
   <p>
    Запустите алгоритм K-Means с параметрами
    <em>
     init='k-means++'
    </em>
    и
    <em>
     random_state=241
    </em>
    . После выделения кластеров все пиксели, отнесенные в один кластер, попробуйте заполнить двумя способами: медианным и средним цветом по кластеру.
   </p>
  </li>
  <li>
   <p>
    Измерьте качество получившейся сегментации с помощью метрики PSNR. Эту метрику нужно реализовать самостоятельно (см.
    <a href="https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio">
     определение
    </a>
    ).
   </p>
  </li>
  <li>
   <p>
    Найдите минимальное количество кластеров, при котором значение PSNR выше 20 (можно рассмотреть не более 20 кластеров, но не забудьте рассмотреть оба способа заполнения пикселей одного кластера). Это число и будет ответом в данной задаче.
   </p>
  </li>
 </ol>
 <p>
 </p>
 <p>
  Ответ на каждое задание — текстовый файл, содержащий ответ в первой строчке. Обратите внимание, что отправляемые файлы не должны содержать перевод строки в конце. Данный нюанс является ограничением платформы Coursera. Мы работаем над тем, чтобы убрать это ограничение.
 </p>
 <asset assettype="image" extension="jpg" id="NVMK7LvZEeWg-hLO0rEOAw" name="parrots">
 </asset>
 <p>
 </p>
 <p>
 </p>
 <p>
 </p>
 <p>
 </p>
 <p>
 </p>
</co-content>
<style>
 body {
    padding: 50px 85px 50px 85px;
}

table th, table td {
    border: 1px solid #e0e0e0;
    padding: 5px 20px;
    text-align: left;
}
input {
    margin: 10px;
}
}
th {
    font-weight: bold;
}
td, th {
    display: table-cell;
    vertical-align: inherit;
}
img {
    height: auto;
    max-width: 100%;
}
pre {
    display: block;
    margin: 20px;
    background: #424242;
    color: #fff;
    font-size: 13px;
    white-space: pre-wrap;
    padding: 9.5px;
    margin: 0 0 10px;
    border: 1px solid #ccc;
}
</style>
<script async="" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
</script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$$','$$'], ['$','$'] ],
      displayMath: [ ["\\[","\\]"] ],
      processEscapes: true
    }
  });
</script>
